{
  "hash": "7379f3947037d5478f1dbfb83e3518d5",
  "result": {
    "markdown": "---\ntitle: \"Day 09: `pluck()`\"\ndate: \"2022-12-09\"\ndescription: |\n  A generalized form of `[[`, `pluck()` lets you safely get an element from deep within a nested data structure (and its friend `chuck()` does the same, but errors if it isn't there).\nimage: pluck-thumb-min.png\nimage-alt: \"purrr::pluck() written on light green background in the style of a marker.\"\ntags: \n  - purrr\nreference-location: margin\n---\n\n\nAs described in the [purrr docs](https://purrr.tidyverse.org/reference/pluck.html)[^1]:\n\n> `pluck()` and `chuck()` implement a generalised form of `[[` that allow you to index deeply and flexibly into data structures. `pluck()` consistently returns `NULL` when an element does not exist, `chuck()` always throws an error in that case [@purrr].\n\nSelecting a single element using R's built-in subsetting operators, [`[[`](https://rdrr.io/r/base/Extract.html) and [`$`](https://rdrr.io/r/base/Extract.html), can be a bit tricky, especially with nested data structures.[^2] The inconsistencies in what is returned by `[[` when an element is missing can be particularly painful when working with JSON data from web APIs. When an element is missing `pluck()` always returns `NULL` (or a value set with the `.default` argument), while `chuck()` always throws an error.\n\nLet's look at examples using some data about the Belcher family from [Bob's Burgers](https://en.wikipedia.org/wiki/Bob%27s_Burgers).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nbelchers <- list(\n  list(\n    \"name\" = \"Bob\",\n    \"age\" = 46,\n    \"father\" = \"Big Bob\",\n    \"mother\" = \"Lily\",\n    \"children\" = list(\"Tina\", \"Gene\", \"Louise\"),\n    \"glasses\" = FALSE\n  ),\n  list(\n    \"name\" = \"Linda\",\n    \"age\" = 45,\n    \"father\" = \"Al\",\n    \"mother\" = \"Gloria\",\n    \"siblings\" = list(\"Gayle\"),\n    \"children\" = list(\"Tina\", \"Gene\", \"Louise\"),\n    \"glasses\" = TRUE\n  ),\n  list(\n    \"name\" = \"Tina\",\n    \"age\" = 13,\n    \"father\" = \"Bob\",\n    \"mother\" = \"Linda\",\n    \"siblings\" = list(\"Gene\", \"Louise\"),\n    \"glasses\" = TRUE\n  ),\n  list(\n    \"name\" = \"Gene\",\n    \"age\" = 11,\n    \"father\" = \"Bob\",\n    \"mother\" = \"Linda\",\n    \"siblings\" = list(\"Tina\", \"Louise\"),\n    \"glasses\" = FALSE\n  ),\n  list(\n    \"name\" = \"Louise\",\n    \"age\" = 9,\n    \"father\" = \"Bob\",\n    \"mother\" = \"Linda\",\n    \"siblings\" = list(\"Tina\", \"Gene\"),\n    \"glasses\" = FALSE\n  )\n)\n```\n:::\n\n\nFor those of you not paying close attention, note that (with the exception of Linda, who has siblings *and* children) the items in our list have missing data/non-existent elements. If we used `[[` with numeric positions to access data in our list, we'd end up with information about different things (the fifth element for the first item on our list, Bob, is `children`, while for our fifth item, Louise, it's `siblings`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbelchers[[1]][[5]] # fifth element for first item\n#> [[1]]\n#> [1] \"Tina\"\n#> \n#> [[2]]\n#> [1] \"Gene\"\n#> \n#> [[3]]\n#> [1] \"Louise\"\nbelchers[[5]][[5]] # fifth element for sixth item\n#> [[1]]\n#> [1] \"Tina\"\n#> \n#> [[2]]\n#> [1] \"Gene\"\n```\n:::\n\n\nThis isn't the end of the world--this is why we name things, after all! But, what do we want to happen if we try to get an element by name and it's not there? If the answer is `NULL`, we're in luck. That's what we'll get with a combination of `[[` and `$`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbelchers[[1]]$children\n#> [[1]]\n#> [1] \"Tina\"\n#> \n#> [[2]]\n#> [1] \"Gene\"\n#> \n#> [[3]]\n#> [1] \"Louise\"\n\nbelchers[[5]]$children\n#> NULL\n```\n:::\n\n\nHowever, using `[[` by position (say, to get the *seventh* element for an item) will throw an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# seventh element for second item (Linda) exists\nbelchers[[2]][[7]]\n#> [1] TRUE\n\n# seventh element for first item (Bob) doesn't exist\ntry(belchers[[1]][[7]])\n#> Error in belchers[[1]][[7]] : subscript out of bounds\n```\n:::\n\n\n`pluck()` and `chuck()` offer us a bit more control in these scenarios. We can use `pluck()` to get `NULL` or a set `.default` value, and `chuck()` if we want this to throw an error. Both verbs accept integer positions, string names, and accessor functions. Unlike `$`, however, partial matches are not accepted.\n\nGetting non-existent `\"children\"` by name:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pluck default is NULL\npluck(belchers, 5, \"children\") \n#> NULL\n\n# can set default to return NA\npluck(belchers, 5, \"children\", .default = NA)\n#> [1] NA\n\n# use `chuck()` to throw an error for a missing element\ntry(chuck(belchers, 5, \"children\"))\n#> Error in chuck(belchers, 5, \"children\") : \n#>   Can't find name `children` in vector.\n```\n:::\n\n\nThe same holds for getting non-existent element by position:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npluck(belchers, 5, 7)\n#> NULL\n\npluck(belchers, 5, 7, .default = NA)\n#> [1] NA\n\ntry(chuck(belchers, 5, 7))\n#> Error in chuck(belchers, 5, 7) : \n#>   Index 2 exceeds the length of plucked object (7 > 6).\n```\n:::\n\n\nAll of this comes in particularly handy when you're using `pluck()` in combination with purrr's [`map()`](https://purrr.tidyverse.org/reference/map.html) functions. Let's say I want to get the first-born child for each Belcher, and have it return `NA` if it doesn't exist.[^3]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbelchers |> \n  map(pluck, \"children\", 1L, .default = NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"Tina\"\n\n[[2]]\n[1] \"Tina\"\n\n[[3]]\n[1] NA\n\n[[4]]\n[1] NA\n\n[[5]]\n[1] NA\n```\n:::\n:::\n\n\n## Learn more\n\nThere's more to `pluck()` than we've covered here. There's assignment variant, `pluck<-()`, which allows you to modify objects within a nested data structure. And a new function, `pluck_exists()` is in the soon-to-be-released development version of purrr, which (as the name suggests) tells you whether or not an element exists. For details on those, see the [`pluck()` dev reference page](https://purrr.tidyverse.org/dev/reference/pluck.html).\n\nThe [`hoist()`](https://tidyr.tidyverse.org/reference/hoist.html) function in tidyr uses the same syntax as `pluck()` to take components of list columns and pull them out into their own top-level columns, which you can learn more about in the tidyr [Rectangling vignette](https://tidyr.tidyverse.org/articles/rectangle.html).\n\nFor more on how `[[` handles [missing and out-of-bound indices](https://adv-r.hadley.nz/subsetting.html#subsetting-oob) see the linked section from Advanced R.\n\n[^1]: Note that [`pluck()`](https://purrr.tidyverse.org/dev/reference/pluck.html) and [`chuck()`](https://purrr.tidyverse.org/dev/reference/chuck.html) have separate function-reference pages in the [development version of purrr](https://purrr.tidyverse.org/dev/).\n\n[^2]: For details, see the section on [selecting a single element](https://adv-r.hadley.nz/subsetting.html#subset-single) in the Subsetting chapter of [Advanced R](https://adv-r.hadley.nz/) [@advR].\n\n[^3]: `map()` is actually powered by `pluck()` under the hood, so you can accomplish some of these things by supplying indices directly to `map()` as a list.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}