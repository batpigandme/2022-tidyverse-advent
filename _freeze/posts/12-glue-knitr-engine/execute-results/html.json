{
  "hash": "33e200d2da37edb3218da9eb63f493f7",
  "result": {
    "markdown": "---\ntitle: \"Day 12: glue's knitr engine\"\ndate: \"2022-12-12\"\ndescription: |\n  Use glue's custom knitr language engine to evaluate chunk contents as a glue template.\nimage: glue-knitr-engine-thumb-min.png\nimage-alt: \"Code cell on left that has glue in curly braces next to backticks, body of which reads 1 + 1 = {1 + 1}. An arrow indicates that the output is to its right. The output reads 1 + 1 = 2.\"\ntags: \n  - glue\n---\n\n\nIf you're unfamiliar with [**glue**](https://glue.tidyverse.org/index.html) [@glue], let me catch you up to speed:\n\n> Glue offers interpreted string literals that are small, fast, and dependency-free. Glue does this by embedding R expressions in curly braces which are then evaluated and inserted into the argument string.\n\nBasically, it lets you pass variables directly into strings by wrapping them in curly braces (`{}`), making for some very reader-friendly string interpolation.\n\nToday, I want to highlight a feature of glue that's discussed less often: its [**custom knitr language engine**](https://glue.tidyverse.org/articles/engines.html)[^1].\n\nTo use the glue engine in an R Markdown or Quarto document, you just need to load the glue library.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glue)\nlibrary(palmerpenguins) # I'm loading this to use its data later\n```\n:::\n\n\nOnce you've done that, you use it by using `glue` as the named engine (as you would for any other language, say `r` or `python` in a code cell), and the contents will be evaluated as a glue template.\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{glue}}\n1 + 1 = {1 + 1}\n```\n````\n\n\n::: {.cell-output .cell-output-stdout}\n```\n1 + 1 = 2\n```\n:::\n:::\n\n\nYou can output markdown or HTML directly into your document, by setting the option `results` to `'asis'`.\n\n\n\n````{.cell-code}\n```{{glue}}\n#| results: 'asis'\n`penguins` has **{nrow(penguins)} rows** and _{ncol(penguins)} columns_.\n```\n````\n\n\n`penguins` has **344 rows** and _8 columns_.\n\n\nAs you can see, the markdown formatting I've used in the chunk above is rendered in the output.\n\nIf you want to pass any arguments to your [`glue()`](https://glue.tidyverse.org/reference/glue.html) call, you can include them as chunk options. For example, let's say I want to use something other than curly braces to surround my R expressions. I can set the opening and closing delimiters with the `.open` and `.close` arguments as options.\n\n\n\n````{.cell-code}\n```{{glue}}\n#| .open: \"<<\"\n#| .close: \">>\"\n#| results: 'asis'\nThe **median waiting time** between eruptions is <<median(faithful$waiting)>>.\n```\n````\n\n\nThe **median waiting time** between eruptions is 76.\n\n\n## Learn more\n\nThe glue package has a whole vignette on its [custom knitr language engines](https://glue.tidyverse.org/articles/engines.html), including a section on the [**`glue_sql` engine**](https://glue.tidyverse.org/articles/engines.html#glue_sql-engine), which I haven't covered here. For the rest of glue's features, see the [package documentation](https://glue.tidyverse.org/index.html).\n\n[^1]: If you want to learn more about custom knitr language engines in general, there's a [section on them](https://bookdown.org/yihui/rmarkdown-cookbook/custom-engine.html#custom-engine) in the R Markdown Cookbook [@rmdcookbook], but you don't need to know that info to use the glue engines.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}