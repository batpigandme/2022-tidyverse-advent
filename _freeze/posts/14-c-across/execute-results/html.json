{
  "hash": "fd419ec923a1c6e108f3d72ab7030f29",
  "result": {
    "markdown": "---\ntitle: \"Day 14: `c_across()`\"\ndate: \"2022-12-14\"\ndescription: |\n  Designed to work with `rowwise()`, `c_across()` uses tidyselect semantics to make it easier to perform row-wise aggregations.\nimage: c-across-thumb-min.png\nimage-alt: \"c_across() written in black against a blue background with slight white stripes.\"\ntags: \n  - dplyr\n---\n\n\nColumns are special in R, which means that operating on data by row takes a bit more thought. The pros and cons of various approaches featuring purrr have been *very* well elucidated by Jenny Bryan in [Row-oriented workflows in R with the tidyverse](https://github.com/jennybc/row-oriented-workflows#readme) (which includes code examples, a slide deck, *and* a webinar recording), and I won't seek to re-create that here.\n\n[**`c_across()`**](https://dplyr.tidyverse.org/reference/c_across.html) came to dplyr [@dplyr] in 2020 (after Jenny's webinar) to make it easier to select variables when doing operations with [`rowwise()`](https://dplyr.tidyverse.org/reference/rowwise.html). Powered by [tidyselect](https://tidyselect.r-lib.org/index.html) [@tidyselect], it uses the same semantics as [`dplyr::select()`](https://dplyr.tidyverse.org/reference/select.html) , allowing you to do things like use `:` to select a range of consecutive variables, and use selection helpers such as `everything()` and `where()`.\n\nFirst, we'll load our library and create some data to play with.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndf <- tibble(\n  id = 1:5,\n  w = seq(5, 25, 5),\n  x = seq(10, 50, 10),\n  y = seq(60, 100, 10),\n  z = seq(100, 500, 100)\n)\n\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 5\n     id     w     x     y     z\n  <int> <dbl> <dbl> <dbl> <dbl>\n1     1     5    10    60   100\n2     2    10    20    70   200\n3     3    15    30    80   300\n4     4    20    40    90   400\n5     5    25    50   100   500\n```\n:::\n:::\n\n\nAs a reminder, `rowwise()` (like `group_by()`) changes how the other verbs work. Without `rowwise()`, the output of our `mutate()` call, below will be the same for every row (since it thinks you are selecting all of each column every time). With `rowwise()`, it will compute by row.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# WITHOUT `rowwise()`\ndf |>\n  mutate(m = mean(c(w, x, y, z)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n     id     w     x     y     z     m\n  <int> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1     5    10    60   100  106.\n2     2    10    20    70   200  106.\n3     3    15    30    80   300  106.\n4     4    20    40    90   400  106.\n5     5    25    50   100   500  106.\n```\n:::\n\n```{.r .cell-code}\n# WITH `rowwise()`\ndf |>\n  rowwise() |>\n  mutate(m = mean(c(w, x, y, z)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n# Rowwise: \n     id     w     x     y     z     m\n  <int> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1     5    10    60   100  43.8\n2     2    10    20    70   200  75  \n3     3    15    30    80   300 106. \n4     4    20    40    90   400 138. \n5     5    25    50   100   500 169. \n```\n:::\n:::\n\n\nTyping all those variable names can get pretty annoying. Let's do our `rowwise()` mutate again, this time with `c_across()` and selecting our range of variables with `:`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  rowwise() |>\n  mutate(m = mean(c_across(w:z)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n# Rowwise: \n     id     w     x     y     z     m\n  <int> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1     5    10    60   100  43.8\n2     2    10    20    70   200  75  \n3     3    15    30    80   300 106. \n4     4    20    40    90   400 138. \n5     5    25    50   100   500 169. \n```\n:::\n:::\n\n\n`rowwise()` is a special form of grouping (it groups *by* row). So, like `group_by()`, you can give it a grouping variable to preserve for each row. Below, we'll preserve `id` for each row. As always, you can use `mutate()` to add a new column to the data frame, or `summarise()` to get just the summary value. We can also use other tidyselect helpers in `c_across(),` such as `everything()` and `where(), which will produce the same results in the cases below`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  rowwise(id) |> \n  mutate(total = sum(c_across(everything())))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 6\n# Rowwise:  id\n     id     w     x     y     z total\n  <int> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     1     5    10    60   100   175\n2     2    10    20    70   200   300\n3     3    15    30    80   300   425\n4     4    20    40    90   400   550\n5     5    25    50   100   500   675\n```\n:::\n\n```{.r .cell-code}\ndf |> \n  rowwise(id) |> \n  summarise(total = sum(c_across(where(is.numeric))))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'id'. You can override using the `.groups`\nargument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 5 × 2\n# Groups:   id [5]\n     id total\n  <int> <dbl>\n1     1   175\n2     2   300\n3     3   425\n4     4   550\n5     5   675\n```\n:::\n:::\n\n\n## Learn more\n\nTo learn more about working with rows in dplyr, see the [**Row-wise operations**](https://dplyr.tidyverse.org/articles/rowwise.html) vignette. For more on [row-oriented workflows in the tidyverse](https://github.com/jennybc/row-oriented-workflows#readme) with purrr, see Jenny Bryan's linked resources, as well as the purrr documentation for the [`pmap()`](https://purrr.tidyverse.org/reference/map2.html) family of functions.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}