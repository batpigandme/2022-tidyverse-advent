{
  "hash": "7eb67e5b549acaa967c29bdd1d83cc4b",
  "result": {
    "markdown": "---\ntitle: \"Day 03: `parse_number()`\"\ndate: \"2022-12-03\"\ndescription:  |\n  readr's parsing functions can come in handy even after you've imported data. `parse_number()` is flexible enough to deal with things like leading characters, trailing white space, and formatting from different locales.\nimage: parse_number_thumb-min.png\nimage-alt: \"The number 1234567.89 shown three times, first using a comma for the grouping mark and a period for the decimal separator, second with a period for the grouping mark and a comma for the decimal separator, and last with a space for a grouping mark and a period for the decimal separator. The grouping marks are highlighted in blue and the decimal mark is highlighted in green.\"\ntags: \n  - readr\n---\n\n\nNumeric data do not always arrive cleanly formatted. In fact, what constitutes \"correct\" formatting varies depending on location and convention. For example, the [decimal separator](https://en.wikipedia.org/wiki/Decimal_separator) may be representated as a period or a comma according to the [ISO 31-0 standards](https://en.wikipedia.org/wiki/ISO_31-0#Numbers), while the grouping mark (that divides numbers into groups of thousands) is usually a comma in the US but a period in many non-English-speaking countries [@wiki:Decimal_separator].\n\nSimilarly, your numeric data may come with leading or trailing non-numeric characters representing units or currency (e.g. $1,000 or 1,000USD). Depending on the situation, you might need this information, which is why the [`parse_guess()`](https://readr.tidyverse.org/reference/parse_guess.html) function in readr [@readr] interprets these as character strings.\n\n[`parse_number()`](https://readr.tidyverse.org/reference/parse_number.html) is your flexible-number-parsing friend for when you **know** you just want the number part of the data. It drops non-numeric characters before the number, and _all_ characters after the first number.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nparse_number(\"$1,000\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n\n```{.r .cell-code}\nparse_number(\"1000USD\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n\n```{.r .cell-code}\nparse_number(\"t1000t1000\") # you only get the first number here\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1000\n```\n:::\n:::\n\n\nYou can use pass readr's [`locale()`](https://readr.tidyverse.org/reference/locale.html) function to the `locale` argument to specify decimal and grouping marks.[^1]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformat(\nc(\n  parse_number(\"1,234,567.89\"), # `locale()` uses US English default\n  parse_number(\"1 234 567.89\", locale = locale(decimal_mark = \".\", grouping_mark = \" \")),\n  parse_number(\"1.234.567,89\", locale = locale(decimal_mark = \",\", grouping_mark = \".\"))\n),\nnsmall = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1234567.89\" \"1234567.89\" \"1234567.89\"\n```\n:::\n:::\n\n\n[^1]: Note that I've used `format()` so that the two decimal places will be printed for these values. It does not affect the parsing of the values.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}